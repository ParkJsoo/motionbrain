# motionbrain Roadmap (Final)

ESP32 기반 모션 제어 + AI 연동 시스템  
개인 연구 / 학습 / 제작 프로젝트

---

## 프로젝트 핵심 정의

motionbrain은 단순한 모터 제어 프로젝트가 아니다.

이 프로젝트의 목표는 다음 흐름을 **일관된 구조**로 구현하는 것이다.

> 입력 → 판단 → 상태 → 움직임 → 피드백

ESP32는:

- 실시간성
- 안전성
- 물리 제어

을 책임지는 **모션 제어 브레인** 역할만 수행한다.

AI, 네트워크, 고수준 판단은  
**외부 시스템과 분리하여 연동**하는 것을 전제로 한다.

---

## 전역 설계 원칙

모든 Phase에서 아래 원칙은 변하지 않는다.

- **안전성 우선**
  - 부팅 직후 항상 SAFE
  - 명시적 arm 없이는 구동 불가
- **가시성**
  - 모든 상태 변화는 로그로 설명 가능
- **확장성**
  - 입력 / 판단 / 실행 계층 분리
- **단계적 진화**
  - “지금 필요한 것만 구현”

---

## Phase 0 — 환경 정리 및 리스크 제거 (완료)

### 목표

- 알 수 없는 펌웨어 제거
- 개발 환경 완전 통제

### 완료 조건

- ESP32 펌웨어 백업 및 초기화 완료
- 테스트 펌웨어만 실행 중
- 외부 장치 / 네트워크 미연결

---

## Phase 1 — 모션 제어 커널 구축 (현재 기준 핵심 Phase)

### Phase 1의 핵심 목표

> **모터가 없어도 무너지지 않는 “모션 제어 커널”을 만든다.**

실제 모터보다:

- 구조
- 상태
- 안전
- 로그

를 먼저 완성한다.

---

### Phase 1-1. 프로젝트 구조 고정

#### 목표

- 확장 가능한 코드 베이스 확보

#### 작업

- 모듈 분리
  - system (상태, 초기화)
  - motor (모터 제어, 초기엔 stub)
  - debug/log (로그 출력)
- main.cpp는 진입점만 담당

#### 완료 기준

- 폴더/파일 구조 고정
- main.cpp 최소화 유지

---

### Phase 1-2. 시스템 상태 머신 구현

#### 목표

- “언제 움직일 수 있는지”를 코드로 강제

#### 기본 상태

- BOOT
- IDLE (기본값, SAFE)
- ARMED (구동 가능)
- FAULT (강제 차단)

#### 상태 전환

- BOOT → IDLE
- arm → ARMED
- stop / timeout → IDLE
- error → FAULT

#### 완료 기준

- 상태 전환 로그 출력
- 상태 없이는 모터 관련 코드 실행 불가

---

### Phase 1-3. 안전 규칙 코드화

#### 목표

- 실수해도 사고로 이어지지 않게 하기

#### 규칙

- 부팅 직후 항상 SAFE
- arm 없이는 PWM 출력 금지
- 명령 타임아웃 시 자동 SAFE
- 로그 없는 동작 금지

#### 완료 기준

- 타임아웃 실제 동작 확인
- SAFE 전환 로그 확인

---

### Phase 1-4. 시리얼 명령 기반 제어

#### 목표

- 네트워크 없이도 명령 흐름 완성

#### 명령

- help
- status
- arm / disarm
- stop
- test (초기엔 로그 전용)

#### 완료 기준

- 시리얼로 상태 전환 가능
- 잘못된 명령 무시 + 로그 출력

---

## Phase 1.5 — Input & Interface (No Motion) ★ 선행 진행

> **하드웨어가 없어도 “입력 → 판단” 계층을 완성한다.**  
> 이 단계에서는 실제 모터는 절대 움직이지 않는다.

---

### Phase 1.5-1. Wi-Fi AP 입력 채널

#### 목표

- 안전한 무선 입력 경로 확보

#### 작업

- ESP32 AP 모드
- 외부 인터넷 연결 없음
- 접속 로그 출력

#### 제한

- 부팅 시 자동 arm 금지
- 네트워크 입력은 명령 생성까지만 허용

---

### Phase 1.5-2. 웹 UI (대시보드 + 명령)

#### 목표

- 상태 가시화
- 명령 전달 실험

#### 기능

- 현재 상태 표시 (IDLE / ARMED / FAULT)
- 명령 버튼 (Forward / Stop 등)

#### 제한

- UI 이벤트 → 모터 직접 제어 금지
- 내부 명령 객체 생성까지만 수행

---

### Phase 1.5-3. 키보드 / 모바일 입력

#### 목표

- 다양한 입력 채널 통합

#### 방식

- PC 키보드 → HTTP / 시리얼
- 모바일 브라우저 → 웹 UI

#### 완료 기준

- 모든 입력이 동일한 명령 인터페이스 사용

---

## Phase 1-5 — TB6612FNG 연동 (물리 제어 시작)

### 목표

- 실제 모터를 **안전하게** 처음 구동

#### 진행 순서

1. 드라이버 전원만 연결 (모터 미연결)
2. STBY / ENABLE 차단 검증
3. PWM 신호 출력 테스트
4. 모터 1개, 낮은 PWM
5. 듀얼 모터 확장

#### 완료 기준

- 급가속/급정지 방지 확인
- 타임아웃 시 물리 차단 확인

---

## Phase 2 — 모션 추상화 계층

### 목표

> “PWM 제어”를 “의미 있는 동작”으로 추상화

#### 예시 API

- move_forward(speed)
- rotate_left(angle)
- stop_smooth()

#### 구조

- 모션 명령 큐
- 중단 / 우선순위 처리

#### 완료 기준

- 저수준 제어 외부 노출 없음

---

## Phase 3 — 입력 · 판단 계층 분리 확장

### 목표

> 입력과 실행의 완전 분리

#### 계층

- Input Layer
- Decision Layer
- Motion Layer

#### 완료 기준

- 입력이 직접 모터 제어 불가
- 판단 계층에서만 상태 전환

---

## Phase 4 — AI 연계 (장기 목표)

### 목표

> ESP32 + 외부 AI 협업 구조 완성

#### 역할 분담

- ESP32: 실시간 제어, 안전 보장
- AI: 전략, 의사결정

#### 통신

- 시리얼 / USB
- 네트워크 (Phase 4에서만)

#### 완료 기준

- AI는 “의도”만 전달
- ESP32는 안전 규칙 안에서만 실행

---

## 최종 상태 정의

motionbrain은:

- 예측 가능하고
- 로그로 설명 가능하며
- 확장 가능한

**지능형 모션 제어 플랫폼**이 된다.

“왜 움직였는지 설명할 수 없는 시스템”은  
motionbrain의 목표가 아니다.
